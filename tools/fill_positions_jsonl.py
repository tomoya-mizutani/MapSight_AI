#!/usr/bin/env python3
"""Fill player position records using detection and tracking assignments.

This utility reads the skeleton ``positions.jsonl`` file produced by
``build_empty_positions_inex.py`` together with the assignments generated by
``assign_tracks_to_players.py``. It populates pixel coordinates, normalised
coordinates, status fields, and metadata for every player-frame record.
"""

from __future__ import annotations

import argparse
import json
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional, Tuple

import cv2


@dataclass
class AssignmentData:
    """Assignment information for a player at a specific frame."""

    px_x: Optional[float]
    px_y: Optional[float]
    status: str
    confidence: float
    notes: Optional[str]


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""

    parser = argparse.ArgumentParser(
        description="Fill positions JSONL file using assignment data",
    )
    parser.add_argument(
        "positions_jsonl",
        type=Path,
        help="Input skeleton positions JSONL file",
    )
    parser.add_argument(
        "assignments_jsonl",
        type=Path,
        help="Assignments JSONL file from tracking",
    )
    parser.add_argument(
        "output_jsonl",
        type=Path,
        help="Output JSONL file with populated positions",
    )
    parser.add_argument(
        "--calib-id",
        type=str,
        default="simple_norm_v1",
        help="Calibration identifier to attach to updated records",
    )
    parser.add_argument(
        "--image-root",
        type=Path,
        default=None,
        help="Optional root directory for resolving relative image paths",
    )
    return parser.parse_args()


def resolve_image_path(path_str: str, image_root: Optional[Path]) -> Path:
    """Resolve an image path relative to an optional root."""

    path = Path(path_str)
    if path.is_file():
        return path
    if image_root is not None:
        candidate = image_root / path
        if candidate.is_file():
            return candidate
    return path


def load_assignments(assignments_path: Path) -> Dict[int, Dict[str, AssignmentData]]:
    """Load assignments and index them by frame and player UID."""

    start = time.perf_counter()
    assignments_by_frame: Dict[int, Dict[str, AssignmentData]] = {}
    with assignments_path.open("r", encoding="utf-8") as handle:
        for line_no, line in enumerate(handle, start=1):
            if not line.strip():
                continue
            data = json.loads(line)
            frame_index = int(data["frame_index"])
            frame_assignments: Dict[str, AssignmentData] = {}
            for entry in data.get("assignments", []):
                player_uid_raw = entry.get("player_uid")
                if not player_uid_raw:
                    continue
                player_uid = str(player_uid_raw)
                px_x_raw = entry.get("px_x")
                px_y_raw = entry.get("px_y")
                px_x = float(px_x_raw) if px_x_raw is not None else None
                px_y = float(px_y_raw) if px_y_raw is not None else None
                frame_assignments[player_uid] = AssignmentData(
                    px_x=px_x,
                    px_y=px_y,
                    status=str(entry.get("status", "unknown")),
                    confidence=float(entry.get("confidence", 0.0)),
                    notes=entry.get("notes"),
                )
            assignments_by_frame[frame_index] = frame_assignments
    duration = time.perf_counter() - start
    message = (
        f"[INFO] Loaded assignments for {len(assignments_by_frame)} frames "
        f"from {assignments_path} in {duration:.2f}s"
    )
    print(message, file=sys.stderr)
    return assignments_by_frame


def get_image_size(
    image_path: str,
    cache: Dict[str, Optional[Tuple[int, int]]],
    image_root: Optional[Path],
) -> Optional[Tuple[int, int]]:
    """Retrieve image dimensions, caching results for reuse."""

    if image_path in cache:
        return cache[image_path]
    resolved = resolve_image_path(image_path, image_root)
    if not resolved.exists():
        warning = f"[WARN] Image not found for size lookup: {resolved}"
        print(warning, file=sys.stderr)
        cache[image_path] = None
        return None
    image = cv2.imread(str(resolved), cv2.IMREAD_UNCHANGED)
    if image is None:
        warning = f"[WARN] Failed to read image for size lookup: {resolved}"
        print(warning, file=sys.stderr)
        cache[image_path] = None
        return None
    height, width = image.shape[:2]
    size = (width, height)
    cache[image_path] = size
    return size


def normalise_coordinates(
    px_x: Optional[float],
    px_y: Optional[float],
    width: Optional[int],
    height: Optional[int],
) -> Tuple[Optional[float], Optional[float]]:
    """Convert pixel coordinates to normalised coordinates."""

    if px_x is None or px_y is None or width is None or height is None:
        return None, None
    if width <= 0 or height <= 0:
        return None, None
    return px_x / float(width), px_y / float(height)


def lookup_image_size(
    image_path: Optional[str],
    cache: Dict[str, Optional[Tuple[int, int]]],
    image_root: Optional[Path],
) -> Optional[Tuple[int, int]]:
    """Return cached image size if the path is valid."""

    if not image_path:
        return None
    return get_image_size(str(image_path), cache, image_root)


def fill_positions(
    positions_path: Path,
    assignments_by_frame: Dict[int, Dict[str, AssignmentData]],
    output_path: Path,
    calib_id: str,
    image_root: Optional[Path],
) -> None:
    """Populate the skeleton positions file with assignment data."""

    start = time.perf_counter()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    image_cache: Dict[str, Optional[Tuple[int, int]]] = {}
    total_records = 0
    updated_records = 0
    missing_assignments = 0
    status_history: Dict[str, str] = {}
    with positions_path.open("r", encoding="utf-8") as source:
        with output_path.open("w", encoding="utf-8") as dest:
            for line_no, line in enumerate(source, start=1):
                if not line.strip():
                    continue
                record = json.loads(line)
                frame_index = int(record.get("frame_index"))
                player_uid = str(record.get("player_uid"))
                assignments = assignments_by_frame.get(frame_index, {})
                assignment = assignments.get(player_uid)
                image_path = record.get("image_path")
                width = height = None
                if (
                    assignment
                    and assignment.px_x is not None
                    and assignment.px_y is not None
                ):
                    size = lookup_image_size(image_path, image_cache, image_root)
                    if size is not None:
                        width, height = size
                if assignment:
                    record["px_x"] = assignment.px_x
                    record["px_y"] = assignment.px_y
                    if width is None or height is None:
                        size = lookup_image_size(image_path, image_cache, image_root)
                        if size is not None:
                            width, height = size
                    x_norm, y_norm = normalise_coordinates(
                        assignment.px_x,
                        assignment.px_y,
                        width,
                        height,
                    )
                    record["x_norm"] = x_norm
                    record["y_norm"] = y_norm
                    record["status"] = assignment.status
                    record["confidence"] = assignment.confidence
                    if assignment.notes is not None:
                        record["notes"] = assignment.notes
                    updated_records += 1
                else:
                    missing_assignments += 1
                    existing_px_x = record.get("px_x")
                    existing_px_y = record.get("px_y")
                    if existing_px_x is not None and existing_px_y is not None:
                        try:
                            px_x_value = float(existing_px_x)
                            px_y_value = float(existing_px_y)
                        except (TypeError, ValueError):
                            px_x_value = px_y_value = None
                        if px_x_value is not None and px_y_value is not None:
                            size = lookup_image_size(
                                image_path, image_cache, image_root
                            )
                            if size is not None:
                                width, height = size
                                x_norm_value, y_norm_value = normalise_coordinates(
                                    px_x_value,
                                    px_y_value,
                                    width,
                                    height,
                                )
                                record["x_norm"] = x_norm_value
                                record["y_norm"] = y_norm_value
                record["calib_id"] = calib_id
                prev_status = status_history.get(player_uid)
                current_status = record.get("status")
                if prev_status == "eliminated" and current_status == "alive":
                    record["status"] = "eliminated"
                    existing_note = record.get("notes")
                    correction = "resurrected status corrected to eliminated"
                    if existing_note:
                        record["notes"] = f"{existing_note} | {correction}"
                    else:
                        record["notes"] = correction
                status_history[player_uid] = record.get("status")
                dest.write(json.dumps(record, ensure_ascii=False) + "\n")
                total_records += 1
    duration = time.perf_counter() - start
    summary = (
        f"[INFO] Filled {updated_records}/{total_records} records "
        f"(missing {missing_assignments}) into {output_path} in {duration:.2f}s"
    )
    print(summary, file=sys.stderr)


def main() -> None:
    """CLI entry point."""

    args = parse_args()
    assignments = load_assignments(args.assignments_jsonl)
    fill_positions(
        positions_path=args.positions_jsonl,
        assignments_by_frame=assignments,
        output_path=args.output_jsonl,
        calib_id=args.calib_id,
        image_root=args.image_root,
    )


if __name__ == "__main__":  # pragma: no cover - CLI entry
    try:
        main()
    except Exception as exc:  # pragma: no cover - CLI error handling
        print(f"[ERROR] {exc}", file=sys.stderr)
        sys.exit(1)
